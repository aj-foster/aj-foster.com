
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
      <title>Absinthe and Apollo in Swift &bull; AJ Foster</title>
    
    <link rel="stylesheet" href="/assets/css/app.css">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Raleway:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Oranienbaum&display=swap&text=0123456789" rel="stylesheet">
    <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Sitewide Atom feed" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="me" href="https://hachyderm.io/@ajf">
  </head>

  <body>

    <div class="cell well">
    
      <section>
        
<nav class="nav">
  <ul>
    <li><a href="/">Home</a></li>
    <li><a href="/about/">About</a></li>
    <li><a href="https://github.com/aj-foster/">GitHub</a></li>
    <li><a href="https://hachyderm.io/@ajf">Social</a></li>
  </ul>
</nav>

        <h1 id="absinthe-and-apollo-in-swift">Absinthe and Apollo in Swift</h1><p>Posted on Feb 23, 2021. <a href="https://github.com/aj-foster/aj-foster.com/discussions">Discuss on GitHub</a></p><div class="article"><p><a href="https://github.com/absinthe-graphql/absinthe">Absinthe</a> is a GraphQL server for the Elixir language, which interacts nicely with the <a href="https://phoenixframework.org/">Phoenix</a> web framework to serve GraphQL queries over HTTP and websockets. I’ve used Absinthe in my paid work, and recently started using it for a side project where subscriptions will be very helpful. If you aren’t familiar, GraphQL subscriptions allow you to ask the server to send updates when certain things happen, rather than repeatedly asking for updates.</p><p>
This time, however, the consumer of the API isn’t a JavaScript web app, but a native application written in Swift. So the full stack is:</p><ul><li>
Absinthe, the GraphQL server  </li><li>
Phoenix channels, an abstraction on top of websockets  </li><li>
Websockets, the transport mechanism  </li><li>
Swift application, the client  </li></ul><p>
Apollo — a project that provides a GraphQL client (and server) for JavaScript — has a <a href="https://github.com/apollographql/apollo-ios">client library</a> for Swift applications. Unfortunately, it doesn’t work out of the box with Phoenix channels. Channels need to be joined, and Absinthe uses channels to communicate subscription data in a particular way. For JavaScript clients, the Absinthe folks provide <a href="https://github.com/absinthe-graphql/absinthe-socket">a library</a> that adapts Apollo’s communication to work with Absinthe over Channels. However, no such thing exists for the Swift client.</p><p>
So I decided <a href="https://github.com/aj-foster/absinthe-socket-transport">to make one</a>.</p><h2 id="-introducing-absinthe-socket-transport">
Introducing Absinthe Socket Transport</h2><p>
The Apollo client for Swift, much like the JavaScript client, has a pluggable transport system. Without changing your query-related code, you can send operations over HTTP or websockets (or a mixture of the two) just by switching which <code class="inline">NetworkTransport</code> you use when initializing the client. There are two base transports available out of the box: an HTTP transport, and an Apollo-compatible websocket transport.</p><p>
To make this work, we need a new <code class="inline">NetworkTransport</code> implementation that would operate on a Phoenix channel. There’s only one problem: I’m not an expert at Swift. Still, challenge accepted.</p><p>
My first solution is based on what was already available:</p><ul><li>
Apollo’s <code class="inline">WebSocketTransport</code> class that implements the <code class="inline">NetworkTransport</code> protocol  </li><li>
The <code class="inline">SwiftPhoenixClient</code><a href="https://github.com/davidstump/SwiftPhoenixClient">library</a> that implements communication over Phoenix channels  </li></ul><p>
Development started with putting the Apollo class and its dependencies on one side of the screen, and slowly rewriting it on the other side of the screen using <code class="inline">SwiftPhoenixClient</code>. Along the way, I learned a lot about how Absinthe and Phoenix communicate.</p><h3 id="-welcome-to-object-oriented-land-(again)">
Welcome to Object-oriented Land (again)</h3><p>
Frankly, it had been a while since writing object-oriented code. Elixir’s functional nature has spoiled me recently, and we use exclusively functional components when working in React at work. Getting back into the groove took some careful thought.</p><p>
Realizing that the <code class="inline">NetworkTransport</code> protocol involves implementing a single function <code class="inline">send</code> was simple enough. I <strong>really</strong> like that protocols can be implemented via extensions in Swift, so instead of…</p><pre><code class="makeup swift"><span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="n">AbsintheSocketTransport</span><span class="p">:</span><span class="w"> </span><span class="n">NetworkTransport</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="c1">// Everything for the class</span><span class="w">
  </span><span class="c1">// Then implement send()</span><span class="w">
</span><span class="p">}</span></code></pre><p>
We can have…</p><pre><code class="makeup swift"><span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="n">AbsintheSocketTransport</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="c1">// Everything for the class</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="k">extension</span><span class="w"> </span><span class="n">AbsintheSocketTransport</span><span class="p">:</span><span class="w"> </span><span class="n">NetworkTransport</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="c1">// Implement send()</span><span class="w">
</span><span class="p">}</span></code></pre><p>
The extension can use private functions on the class, too. Although the first release fo the package has rather messy code in the extension, I’m really glad that it could be separated out.</p><p>
Getting back to chaining methods instead of piping functions was an adjustment, but luckily the <code class="inline">SwiftPhoenixClient</code> makes it easy with its return values. There is a nice consistency between having a function return a modified version of its first argument and having a method return the original object.</p><h3 id="-welcome-to-thread-land-(again)">
Welcome to Thread Land (again)</h3><p>
The isolated processes in the Erlang runtime are really nice. Having data always copied between processes, and not having to worry about <em>retain cycles</em>, means I had a mental adjustment to make.</p><p><code class="inline">SwiftPhoenixLibrary</code> offers two variants of many of its methods: one where you manage your own retain cycles, and one where they manage it for you. The existence of these options was important to remind me to be careful. I found it nice to begin with the “we’ll do it for you” variants and transition to the self-managed ones as time went on. There’s probably something wrong with my implementation, but it’s a start.</p><p>
I’ll always wonder about the self-talk implications of typing <code class="inline">[weak self]</code> so much.</p><h3 id="-creating-a-swift-package">
Creating a Swift Package</h3><p>
It seems like there are several ways to manage packages in Swift. I’m unfamiliar with the community trends, but it seems like <em>Swift Package Manager</em> is the newest and most well-supported within Xcode. The documentation for creating a package is friendly enough, but it took some trial and error to get the main manifest right. Hopefully it isn’t offensive not to immediately support the other package managers.</p><p>
Using the package locally was not altogether fun. Xcode and Swift Package Manager support referencing a local copy of the package, but you still have to commit and refresh the dependency to use any changes. Luckily most of the code was originally written within the project where it was needed before creating a separate package. In the future I would love to investigate this more.</p><p>
Also, the package doesn’t have any tests. That’s a lesson for another day.</p><h2 id="-broader-perspective">
Broader Perspective</h2><p>
Elixir as a language is basically complete, according to its creator. I would agree; the fact that he was recently able to bring Elixir to the realm of high-performance <a href="https://github.com/elixir-nx/nx">numerical computing</a> using a <strong>library</strong> rather than modifications to the core language is a huge testament to its extensibility.</p><p>
So what’s left to build? Stuff like this. We’ve laid the groundwork for an incredible platform, and now it’s time to go back and fill in the little holes. How Elixir and its widely-adopted libraries interact with other languages is a great place to focus.</p><p>
I don’t expect anyone to use <a href="https://github.com/aj-foster/absinthe-socket-transport">Absinthe Socket Transport</a>, but it’s there if you need it.</p></div>
      </section>
    </div>





    <footer>
      <div class="darkmode">
        <input type="checkbox" id="darkmode">
        <label for="darkmode">Toggle Dark Mode</label>
      </div>
      <div>
        Created with ♥︎ by AJ Foster. <a href="https://github.com/aj-foster/aj-foster.com/">Source</a>
      </div>
    </footer>
    <script defer data-domain="aj-foster.com" src="https://plausible.io/js/script.js"></script>
    <script async defer src="/assets/js/colors.js"></script>
  </body>
</html>
